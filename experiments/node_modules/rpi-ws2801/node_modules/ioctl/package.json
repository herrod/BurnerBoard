{
  "name": "ioctl",
  "version": "0.0.7",
  "description": "nodejs ioctl wrapper",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "install": "node-gyp rebuild"
  },
  "keywords": [
    "ioctl",
    "syscall"
  ],
  "author": {
    "name": "Santiago Gimeno",
    "email": "santiago.gimeno@gmail.com"
  },
  "license": {
    "type": "ISC",
    "url": "https://github.com/santigimeno/node-ioctl/blob/master/LICENSE"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/santigimeno/node-ioctl.git"
  },
  "dependencies": {
    "bindings": "^1.1.1",
    "nan": "^1.2.0"
  },
  "gypfile": true,
  "readme": "node-ioctl\n==========\n\nnode ioctl wrapper\n\nInstallation\n------------\n\nInstall with `npm`:\n\n``` bash\n$ npm install ioctl\n```\n\nExamples\n--------\n\nRead bytes of the next pending datagram using FIONREAD.\nAs it takes a pointer as a parameter, it's straightforward using a Buffer as a parameter.\n\n```\nvar dgram = require('dgram');\nvar ioctl = require('ioctl');\n\nvar FIONREAD = 0x541B;\n\nvar s = dgram.createSocket('udp4');\ns.bind(1234, function(err) {\n    if (err) {\n        throw err;\n    }\n\n    var s1 = dgram.createSocket('udp4');\n    var message = new Buffer(\"Some bytes\");\n    s1.send(message, 0, message.length, 1234, \"localhost\", function(err, bytes) {\n        var length = new Buffer(4);\n        var ret = ioctl(s._handle.fd, FIONREAD, length);\n        console.log('Pending bytes: ' + length.readInt32LE(0));\n        s1.close();\n        s.close();\n    });\n});\n```\n\nFor other cases, involving complex structs, we can use the `ref`, `ref-array` and `ref-struct` modules.\n\n```\nvar fs = require('fs');\nvar ioctl = require('ioctl');\nvar ref = require('ref');\nvar ArrayType = require('ref-array');\nvar StructType = require('ref-struct');\n\nvar TTY = '/dev/tty1';\nvar TCGETA = 0x5405;\nvar TIOCEXCL = 0x540C;\n\n// #define NCC 8\n// struct termio {\n// unsigned short c_iflag; /* input mode flags */\n// unsigned short c_oflag; /* output mode flags */\n// unsigned short c_cflag; /* control mode flags */\n// unsigned short c_lflag; /* local mode flags */\n// unsigned char c_line; /* line discipline */\n// unsigned char c_cc[NCC]; /* control characters */\n// };\n\n// define the \"snd_hwdep_info\" struct type\nvar termio = StructType({\n    c_iflag : ref.types.ushort,\n    c_oflag : ref.types.ushort,\n    c_cflag : ref.types.ushort,\n    c_lflag : ref.types.ushort,\n    c_line : ref.types.uchar,\n    c_cc : ArrayType(ref.types.uchar, 8)\n});\n\nfs.open(TTY, 'r+', function(err, fd) {\n    if (err) {\n        throw err;\n    }\n\n    var info = new termio();\n    var ret = ioctl(fd, TCGETA, info.ref());\n    console.log('TCGETA ret: ' + ret);\n    console.log('c_iflag: ' + info.c_iflag);\n    console.log('c_oflag: ' + info.c_oflag);\n    console.log('c_cflag: ' + info.c_cflag);\n    console.log('c_lflag: ' + info.c_lflag);\n    console.log('c_line: ' + info.c_line);\n    console.log('c_cc: ' + info.c_cc.buffer.toString());\n    ret = ioctl(fd, TIOCEXCL);\n    console.log('TIOCEXCL ret: ' + ret);\n    fs.close(fd);\n});\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/santigimeno/node-ioctl/issues"
  },
  "_id": "ioctl@0.0.7",
  "dist": {
    "shasum": "d5ece11cbd682843772ccf53c4ccfe1a26b1683e"
  },
  "_from": "ioctl@",
  "_resolved": "https://registry.npmjs.org/ioctl/-/ioctl-0.0.7.tgz"
}
